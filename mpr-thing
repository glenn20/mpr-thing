#!/usr/bin/python3

import os, select, re, sys

from mpremote.console import ConsolePosix
from mpremote.pyboard import PyboardError

def hard_reset(pyb, out_callback):
    try:
        pyb.serial = pyb.serial.orig_serial
    except AttributeError:
        pass
    pyb.serial.dtr = not pyb.serial.dtr
    time.sleep(0.1)
    pyb.serial.dtr = not pyb.serial.dtr
    pyb.mounted = False

def cursor_column(console_in, console_out_write):
    console_out_write(b'\x1b[6n')   # Query terminal for cursor position
    buf = b''
    for i in range(10):             # Don't wait forever - just in case
        if isinstance(console_in, ConsolePosix):
            select.select([console_in.infd], [], [], 0.1)
        else:
            # TODO: Windows terminal code is untested - I hope it works...
            for i in range(10):     # Don't wait forever - just in case
                if console_in.inWaiting():
                    break
                time.sleep(0.01)
        c = console_in.readchar()
        buf += c
        if c == b'R':               # Wait for end of escape sequence
            break
    else:
        return None

    try:
        pos = re.match(r'^\x1b\[(\d)*;(\d*)R', buf.decode()).groups()
        return int(pos[1])
    except AttributeError:
        return None

# A context manager for the raw repl
class raw_repl:
    def __init__(self, pyb, write_fn, soft_reset=True):
        self.pyb = pyb
        self.soft_reset = soft_reset
        self.write_fn = write_fn

    def __enter__(self):
        if self.soft_reset:
            self.pyb.enter_repl()
        else:
            self.pyb.enter_raw_repl_without_soft_reset()
        return self.pyb

    def __exit__(self, exc_type, value, traceback):
        self.pyb.exit_raw_repl()
        self.pyb.read_until(4, b">>> ")
        if exc_type == PyboardError:
            self.write_fn(b"PyboardError: ")
            if len(value.args) == 3:
                self.write_fn(value.args[1])
                self.write_fn(value.args[2])
            else:
                self.write_fn(value.args[0].encode())
            return True
        elif exc_type == KeyboardInterrupt:
            return True
        elif exc_type in (OSError, FileNotFoundError):
            self.write_fn("{}: {}".format(exc_type.__name__, value).encode())
            return True
        elif value != None:
            self.write_fn(b"Error:: ")
            for arg in value.args:
                self.write_fn(bytes("{}".format(arg), 'utf8'))

# This is going to override do_repl_main_loop in the mpremote module
# It interprets a "!" or "%" character typed at the start of a line
# at the base python prompt as starting a "magic" command.
def my_do_repl_main_loop(pyb, console_in, console_out_write, file_to_inject):
    at_prompt, beginning_of_line, prompt_char_count = False, False, 0
    local, remote = LocalCmd(), RemoteCmd(pyb, console_out_write)
    while True:
        if isinstance(console_in, ConsolePosix):
            # TODO pyb.serial might not have fd
            select.select([console_in.infd, pyb.serial.fd], [], [])
        else:
            while not (console_in.inWaiting() or pyb.serial.inWaiting()):
                time.sleep(0.01)
        c = console_in.readchar()
        if c:
            if c == b"\x1d":  # ctrl-], quit
                break
            elif c == b"\x04":  # ctrl-D
                # do a soft reset and reload the filesystem hook
                pyb.soft_reset_with_mount(console_out_write)
                beginning_of_line = True
                remote.reset_hooks()
            elif c == b"\x12":  # ctrl-R
                # Toggle DTR (hard reset) and reload the filesystem hook
                hard_reset(pyb, console_out_write)
                beginning_of_line = True
                remote.reset_hooks()
            elif c == b"\x0b":  # ctrl-k, inject script
                console_out_write(bytes("Injecting %s\r\n" % file_to_inject, "utf8"))
                pyb.enter_raw_repl_without_soft_reset()
                with open(file_to_inject, "rb") as f:
                    pyfile = f.read()
                try:
                    pyb.exec_raw_no_follow(pyfile)
                except pyboard.PyboardError as er:
                    console_out_write(b"Error:\r\n")
                    console_out_write(er)
                pyb.exit_raw_repl()
                beginning_of_line = True
            elif (c == b"!" and at_prompt  # Magic sequence if at start of line
                    and (beginning_of_line
                        or cursor_column(console_in, console_out_write) == 5)):
                console_in.exit()
                with raw_repl(pyb, console_out_write, soft_reset=False):
                    local.cmdloop()
                console_in.enter()
                pyb.serial.write(b"\x0d")  # Force another prompt
                beginning_of_line = True
            elif (c == b"%" and at_prompt  # Magic sequence if at start of line
                    and (beginning_of_line
                        or cursor_column(console_in, console_out_write) == 5)):
                console_in.exit()
                with raw_repl(pyb, console_out_write, soft_reset=False):
                    remote.cmdloop()
                console_in.enter()
                pyb.serial.write(b"\x0d")  # Force another prompt
                beginning_of_line = True
            elif c == b"\x0d":  # ctrl-k, inject script
                pyb.serial.write(c)
                beginning_of_line = True
            else:
                pyb.serial.write(c)
                beginning_of_line = False

        try:
            n = pyb.serial.inWaiting()
        except OSError as er:
            if er.args[0] == 5:  # IO error, device disappeared
                print("device disconnected")
                break

        if n > 0:
            c = pyb.serial.read(1)
            if c is not None:
                # pass character through to the console
                oc = ord(c)
                if oc in (8, 9, 10, 13, 27) or 32 <= oc <= 126:
                    console_out_write(c)
                else:
                    console_out_write(b"[%02x]" % ord(c))

                # Set at_prompt=True if we see the prompt string
                # Stays set till the next newline char
                if oc == b"\n>>> "[prompt_char_count]:
                    at_prompt = False           # Reset at_prompt after '\n'
                    prompt_char_count += 1
                    if prompt_char_count == 5:
                        prompt_char_count = 0
                        at_prompt = True
                else:
                    prompt_char_count = 0

from mpremote import main

# Override the mpremote main repl loop
main.do_repl_main_loop = my_do_repl_main_loop

import time, cmd, shutil, readline

class LocalCmd(cmd.Cmd):
    prompt = '\r>>> !'
    doc_header = """Execute a shell command on the local host, eg:
                    !ls
                    !cd ..
                 """

    # Completion of filenames on the local filesystem
    def completedefault(self, match, line, begidx, endidx):
        try:
            sep = match.rfind('/')
            d, match = match[:sep+1], match[sep+1:]
            _, dirs, files = next(os.walk(d or '.'))
            files = [d + f for f in files if f.startswith(match)]
            files.extend(d + f + '/' for f in dirs if f.startswith(match))
            files.sort()
            return files
        except:
            traceback.print_exc()

    # Completion of directories on the local filesystem
    def complete_cd(self, text, line, begidx, endidx):
        return [
            f for f in self.complete_filename(text, line, begidx, endidx)
            if f.endswith('/')]

    def do_cd(self, line):
        """Change the current directory on the local host:
            !cd ..
        This will call os.chdir() instead of executing in a sub-shell."""
        for arg in line.split():
            os.chdir(arg)

    def default(self, line):
        os.system(line)
        return True

    def emptyline(self):
        return True

# Upload support code for the magic commands to the board
cmd_hook_code = """\
import uos

class _MPR:
    def __init__(self, columns=80):
        self.columns = columns

    def is_dir(self, file, state=True):
        try:
            return bool(uos.stat(file)[0] & 0x4000) == bool(state)
        except OSError as err:
            if not state:     # Only print this once
                print('ls: cannot access "{}": {}'.format(file, err))
            return False

    def lsfiles(self, files):
        files = list(files)
        if not files: return
        w = max(len(f) for f in files) + 1
        cols = self.columns // w
        fmt = '{:' + str(w) + '}'
        n = 1
        for f in files:
            print(fmt.format(f), end=('' if n % cols and n < len(files) else '\\n'))
            n += 1

    def ls(self, line):
        args = line.split() or ['.']
        files = [f for f in args if self.is_dir(f, False)]
        args.sort(); files.sort()
        if files:
            self.lsfiles(files)
        firsttime = True
        for d in (f for f in args if self.is_dir(f, True)):
            if (len(args) > 1):
                print('' if firsttime else '\\n', d, ':', sep='')
                firsttime = False
            self.lsfiles(sorted(
                f[0] + ('/' if f[1] & 0x4000 else '')  # Add / to directories
                for f in uos.ilistdir(d)))

    def file_matches(self, match):
        import uos
        sep = match.rfind('/')
        d, match = match[:sep+1], match[sep+1:]
        print([
            (d if d != '.' else '') + f[0] + ('/' if f[1] & 0x4000 else '')  # Add / to directories
            for f in uos.ilistdir(d or '.') if f[0].startswith(match)
        ])

_mpr = _MPR()
"""

# Apply basic compression on hook code.
hook_subs = (
    (" *#.*$", "",  {'flags': re.MULTILINE}),
    ("\n\n+",  "\n",),
    ("    ",   " ", ),
    ("rd_",    "r", ),
    ("wr_",    "w", ),
    ("buf4",   "b4",),
)
def do_hook_subs(subs, code):
    for sub in subs:
        a, b, *flags = sub
        flags = flags[0] if flags else {}
        code = re.sub(a, b, code, **flags)
    return code

cmd_hook_code = do_hook_subs(hook_subs, cmd_hook_code)

DELIMS = ' \t\n>;'

class RemoteCmd(cmd.Cmd):
    base_prompt = '\r>>> %'
    doc_header = (
        'Execute "%magic" commands at the micropython prompt, eg: %ls /\n'
        'Use "%%" to enter multiple command mode.')

    def __init__(self, pyb, console_out_write):
        self.pyb = pyb
        self.write = console_out_write
        self.prompt = self.base_prompt
        self.hooks_loaded = False
        self.single_cmd_mode = True
        readline.set_completer_delims(DELIMS)
        super().__init__()

        # Set the completion functions
        fname = self.complete_filename
        self.complete_ls    = fname
        self.complete_cat   = fname
        self.complete_mv    = fname
        self.complete_rm    = fname
        self.complete_get   = fname
        self.complete_put   = fname
        self.complete_edit  = fname
        fname = self.complete_directory
        self.complete_cd    = fname
        self.complete_mkdir = fname
        self.complete_rmdir = fname
        fname = self.complete_local_filename
        self.complete_put   = fname
        self.complete_mount = fname
        fname = self.complete_local_directory
        self.complete_lcd   = fname

    def preloop(self):
        self._ensure_hooks()
        self.single_cmd_mode = True

    def precmd(self, line):
        if not self.single_cmd_mode and line and line[0] == "%":
            return line[1:]
        else:
            return line

    def default(self, line):
        if self.single_cmd_mode and line.strip() == "%":
            self.prompt = "%% "
            self.write(
                b'Enter magic commands (try "help" for a list)\n'
                b'Type "quit" or ctrl-D to return to micropython:\n')
            self.single_cmd_mode = False
        elif not self.single_cmd_mode and line.strip() in ("exit", "quit", "EOF"):
            self.prompt = self.base_prompt
            self.single_cmd_mode = True
        else:
            self.write('Unknown command: "{}"'.format(line.strip()).encode())

    def postcmd(self, stop, line):
        if not self.single_cmd_mode:
            self.write(b"\n")
        return self.single_cmd_mode  # Force exit after one command

    def emptyline(self):            # Else empty lines repeat last command
        pass

    # touch, sync
    def reload_hooks(self):
        #if self.pyb.eval('"_mpr" in globals()') == b"False":
        self.pyb.exec_(cmd_hook_code)
        self.pyb.exec_(
            '_mpr.columns = {}'.format(shutil.get_terminal_size().columns))
        self.hooks_loaded = True

    def reset_hooks(self):
        self.hooks_loaded = False

    def _ensure_hooks(self):
        if not self.hooks_loaded:
            self.reload_hooks()

    # Completion of filenames on the board for commands
    def complete_filename(self, text, line, begidx, endidx):
        try:        # Cmd invisibly swallows all exceptions
            res = self.pyb.exec_('_mpr.file_matches("{}")'.format(text))
            return eval(res)
        except:
            traceback.print_exc()

    # Completion of directories on the board
    def complete_directory(self, text, line, begidx, endidx):
        try:
            return [
                f for f in self.complete_filename(text, line, begidx, endidx)
                if f.endswith('/')]
        except:
            traceback.print_exc()

    # Completion of filenames on the local filesystem
    def complete_local_filename(self, match, line, begidx, endidx):
        try:
            sep = match.rfind('/')
            d, match = match[:sep+1], match[sep+1:]
            _, dirs, files = next(os.walk(d or '.'))
            files = [d + f for f in files if f.startswith(match)]
            files.extend(d + f + '/' for f in dirs if f.startswith(match))
            files.sort()
            return files
        except:
            traceback.print_exc()

    # Completion of directories on the local filesystem
    def complete_local_directory(self, text, line, begidx, endidx):
        return [
            f for f in self.complete_filename(text, line, begidx, endidx)
            if f.endswith('/')]

    def do_ls(self, line):
        """List files on the board:\n  %ls [file_or_dir1 ...]"""
        res = self.pyb.exec_('_mpr.ls("{}")'.format(line))
        if res: self.write(res[:-1])

    def do_cat(self, line):
        """List the contents of files on the board:\n    %cat file [file2 ...]"""
        for arg in line.split():
            self.pyb.fs_cat(arg)

    def do_mv(self, line):
        """Rename/move a file on the board:\n    %mv old new"""
        old, new = line.split()
        res = self.pyb.exec_('uos.rename("{}", "{}")'.format(old, new))
        if res: self.write(res[:-1])

    def do_rm(self, line):
        """Delete files from the board:\n    %rm file1 [file2 ...]"""
        for arg in line.split():
            self.pyb.fs_rm(arg)

    def do_get(self, line):
        """Copy a file from the board to a local folder:\n
            %get file1 [file2 ... local_dir]"""
        for arg in line.split():
            self.pyb.fs_get(arg, os.path.basename(arg))

    def do_put(self, line):
        """Copy one local file to the current folder on the board:
            put file
        Copy one or more local files to a folder on the board:
            %put file1 [... filen] folder"""
        for arg in line.split():
            self.pyb.fs_put(arg, os.path.basename(arg))

    def do_edit(self, line):
        """Copy a file from the board, open it in your editor, then copy it back:
            %edit file1 [file2 ...]
        """
        args = line.split()
        for arg in args:
            import tempfile
            fd, fname = tempfile.mkstemp()
            os.close(fd)
            self.pyb.fs_get(arg, fname)
            if 0 == os.system(f'${{EDITOR:-/usr/bin/vi}} {fname}'):
                self.pyb.fs_put(fname, arg)
            os.remove(fname)

    def do_cd(self, line):
        """Change the current direcory on the board (with os.setpwd()):
            %cd /lib"""
        args = line.split()
        res = self.pyb.exec_(
            'import uos;uos.chdir("{}");print(uos.getcwd())'
            .format(args[0] if args else '/'))
        if res: self.write(res[:-1])

    def do_pwd(self, line):
        """Print the current working directory on the board:\n    %pwd"""
        res = self.pyb.exec_('import uos;print(uos.getcwd())')
        if res: self.write(res[:-1])

    def do_lcd(self, line):
        """Change the current directory on the local host:
            %lcd ..
        This is the same as:
            !cd .."""
        for arg in line.split():
            os.chdir(arg)

    def do_mkdir(self, line):
        """Create a new directory on the board:\n    %mkdir /test"""
        for arg in line.split():
            self.pyb.fs_mkdir(arg)

    def do_rmdir(self, line):
        """Delete/remove a directory on the board (if it is empty)
            %rmdir /test"""
        for arg in line.split():
            self.pyb.fs_rmdir(arg)

    def do_time(self, line):
        """Set or print the time on the board:
            %time set       : Set the RTC clock on the board from the local time
            %time set utc   : Set the RTC clock on the board from UTC time
            %time           : Print the RTC clock time on the board
        """
        args = line.split()
        if args and args[0] == 'set':
            from time import gmtime, localtime
            t = gmtime() if len(args) > 1 and args[1] == 'utc' else localtime()
            res = self.pyb.exec_(
                'from machine import RTC;RTC().init({})'.format(
                    (t.tm_year, t.tm_mon, t.tm_mday, 0, t.tm_hour, t.tm_min, t.tm_sec, 0)))
            if res: self.write(res)
        from time import asctime
        res = self.pyb.exec_('import utime;print(utime.localtime())')
        t = eval(res)
        self.write(asctime((t[0], t[1], t[2], t[3], t[4], t[5], 0, 0, 0)).encode())

    def do_mount(self, line):
        """Mount a local folder onto the board at \"/remote\" as a Virtual FileSystem:
            %mount [folder]   : If no folder specified use \".\""""
        args = line.split()
        self.pyb.mount_local(args[0] if args else ".")
        res = self.pyb.exec_('import uos;print(uos.getcwd())')
        if res: self.write(res)

    def do_umount(self, line):
        """Unmount any Virtual Filesystem mounted at \"/remote\" on the board:
            %umount"""
        # Must chdir before umount or bad things happen.
        self.pyb.exec_('import uos;uos.getcwd()[:7]=="/remote" and uos.chdir("/")')
        res = self.pyb.exec_('uos.umount("/remote")')
        if res: self.write(res)
        try:
            # Unhook the SerialIntercept
            self.pyb.serial = pyb.serial.orig_serial
        except AttributeError:
            pass
        self.pyb.mounted = False
        res = self.pyb.exec_('print(uos.getcwd())')
        if res: self.write(res)  # Print the current directory in case it changed

    def do_gc(self, line):
        """Run the micropython garbage collector on the board to free memory.
        Will also print the free memory before and after gc:
            %gc"""
        res = self.pyb.exec_(
            'from gc import mem_free,collect;'
            'print("Before GC: Free bytes =", mem_free());'
            'collect();'
            'print("After  GC: Free bytes =", mem_free());'
        )
        if res: self.write(res)

if __name__ == "__main__":
    sys.exit(main.main())
