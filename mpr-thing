#!/usr/bin/env python3

# MIT License

# Copyright (c) 2021 @glenn20

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# vscode-fold=2

import os, select, re, sys, readline

from mpremote.pyboard import PyboardError, stdout_write_bytes
from mpremote.pyboardextended import PyboardExtended, SerialIntercept
try:
    from mpremote.console import ConsolePosix, ConsoleWindows
except ImportError:
    from mpremote.main import ConsolePosix, ConsoleWindows   # type: ignore

from typing import (
    Any, Dict, Generator, Union, Callable, Optional, List, Tuple, cast)

Writer = Callable[[bytes], None]  # A type alias for console write functions

from colorama import init as colorama_init  # For ansi colour on Windows

colorama_init()

HISTORY_FILE = '~/.mpr-thing.history'
OPTIONS_FILE = '.mpr-thing.options'
RC_FILE      = '.mpr-thing.rc'


def hard_reset(pyb: PyboardExtended) -> None:
    'Toggle DTR on the serial port to force a hardware reset of the board.'
    if isinstance(pyb.serial, SerialIntercept):
        pyb.serial = pyb.serial.orig_serial
    pyb.serial.dtr = not pyb.serial.dtr         # type: ignore
    time.sleep(0.1)
    pyb.serial.dtr = not pyb.serial.dtr         # type: ignore
    pyb.mounted = False


def cursor_column(
        console_in: Union[ConsolePosix, ConsoleWindows],
        console_out_write: Writer) -> int:
    "Query the console to get the current cursor column number."
    console_out_write(b'\x1b[6n')   # Query terminal for cursor position
    buf = b''
    for _ in range(10):             # Don't wait forever - just in case
        if isinstance(console_in, ConsolePosix):
            select.select([console_in.infd], [], [], 0.1)
        else:
            # TODO: Windows terminal code is untested - I hope it works...
            for i in range(10):     # Don't wait forever - just in case
                if console_in.inWaiting():
                    break
                time.sleep(0.01)
        c = console_in.readchar()
        buf += c
        if c == b'R':               # Wait for end of escape sequence
            break
    else:
        return -1

    match = re.match(r'^\x1b\[(\d)*;(\d*)R', buf.decode())
    return int(match.groups()[1]) if match else -1


# A context manager to catch exceptions from pyboard and others
class catcher:
    # Save the last exception for use outside the context manager
    exception: Union[Exception, PyboardError, None] = None

    def __init__(self, write_fn: Writer):
        self.write_fn = write_fn
        catcher.exception = None

    def __enter__(self) -> Any:
        catcher.exception = None
        pass

    def __exit__(
            self, exc_type: Any, value: Exception, tr: Any) -> bool:
        catcher.exception = None
        if exc_type == PyboardError:
            catcher.exception = value
            self.write_fn(b"PyboardError: ")
            if len(value.args) == 3:    # Raised by Pyboard.exec_()
                self.write_fn(value.args[1])
                self.write_fn(value.args[2])
            else:                       # Others just include a single message
                self.write_fn(value.args[0].encode())
        elif exc_type == KeyboardInterrupt:
            catcher.exception = value
        elif exc_type in (OSError, FileNotFoundError):
            self.write_fn("{}: {}\r\n".format(
                exc_type.__name__, value).encode())
        elif value is not None:
            catcher.exception = value
            self.write_fn(b"Error:: ")
            for arg in value.args:
                self.write_fn(bytes("{}".format(arg), 'utf8'))
            traceback.print_exc()
        return True


# A context manager for the raw_repl
class raw_repl(catcher):
    def __init__(
            self,
            pyb: PyboardExtended,
            write_fn: Writer,
            soft_reset: bool = True):
        self.pyb = pyb
        self.soft_reset = soft_reset
        super().__init__(write_fn)

    def __enter__(self) -> PyboardExtended:
        super().__enter__()
        if self.soft_reset:
            self.pyb.enter_raw_repl()
        else:
            self.pyb.enter_raw_repl_without_soft_reset()
        return self.pyb

    def __exit__(
            self, exc_type: Any, value: Exception, traceback: Any) -> bool:
        self.pyb.exit_raw_repl()
        self.pyb.read_until(4, b">>> ")
        return super().__exit__(exc_type, value, traceback)


# This is going to override do_repl_main_loop in the mpremote module
# It interprets a "!" or "%" character typed at the start of a line
# at the base python prompt as starting a "magic" command.
def my_do_repl_main_loop(
        pyb:                PyboardExtended,
        console_in:         Union[ConsolePosix, ConsoleWindows],
        console_out_write:  Writer,
        file_to_inject:     str) -> None:

    'An overload function for the main repl loop in "mpremote".'
    at_prompt, beginning_of_line, prompt_char_count = False, False, 0
    local, remote = LocalCmd(), RemoteCmd(pyb, console_out_write)
    history_file = os.path.expanduser(HISTORY_FILE)
    if os.path.isfile(history_file):
        readline.read_history_file(history_file)
    while True:
        if isinstance(console_in, ConsolePosix):
            # TODO pyb.serial might not have fd
            select.select(
                [console_in.infd, pyb.serial.fd], [], [])  # type: ignore
        else:
            while not (console_in.inWaiting() or pyb.serial.inWaiting()):
                time.sleep(0.01)
        c = console_in.readchar()
        if c:
            if c == b"\x1d":  # ctrl-], quit
                break
            elif c == b"\x04":  # ctrl-D
                # do a soft reset and reload the filesystem hook
                pyb.soft_reset_with_mount(console_out_write)
                beginning_of_line = True
                remote.reset_hooks()
            elif c == b"\x12":  # ctrl-R
                # Toggle DTR (hard reset) and reload the filesystem hook
                hard_reset(pyb)
                beginning_of_line = True
                remote.reset_hooks()
            elif c == b"\x0b":  # ctrl-k, inject script
                console_out_write(
                    bytes("Injecting %s\r\n" % file_to_inject, "utf8"))
                pyb.enter_raw_repl_without_soft_reset()
                with open(file_to_inject, "rb") as f:
                    pyfile = f.read()
                try:
                    pyb.exec_raw_no_follow(pyfile)
                except PyboardError as err:
                    console_out_write(b"Error:\r\n")
                    console_out_write(repr(err).encode('utf-8'))
                pyb.exit_raw_repl()
                beginning_of_line = True
            elif (c == b"!" and at_prompt  # Magic sequence if at start of line
                    and (beginning_of_line or
                         cursor_column(console_in, console_out_write) == 5)):
                console_out_write(b"\x1b[2K")  # Clear other chars on line
                pyb.serial.write(c)
                console_in.exit()
                with raw_repl(pyb, console_out_write, soft_reset=False):
                    local.cmdloop()
                console_in.enter()
                pyb.serial.write(b"\x0d")  # Force another prompt
                beginning_of_line = True
            elif (c == b"%" and at_prompt  # Magic sequence if at start of line
                    and (beginning_of_line or
                         cursor_column(console_in, console_out_write) == 5)):
                console_out_write(b"\x1b[2K")  # Clear other chars on line
                pyb.serial.write(c)
                console_in.exit()
                with raw_repl(pyb, console_out_write, soft_reset=False):
                    remote.cmdloop()
                console_in.enter()
                beginning_of_line = True
            elif c == b"\x0d":
                pyb.serial.write(c)
                beginning_of_line = True
            else:
                pyb.serial.write(c)
                beginning_of_line = False

        n = 0
        try:
            n = pyb.serial.inWaiting()
        except OSError as er:
            if er.args[0] == 5:  # IO error, device disappeared
                print("device disconnected")
                break

        if n > 0:
            c = pyb.serial.read(1)
            if c is not None:
                # pass character through to the console
                oc = ord(c)
                if oc in (8, 9, 10, 13, 27) or 32 <= oc <= 126:
                    console_out_write(c)
                else:
                    console_out_write(b"[%02x]" % ord(c))

                # Set at_prompt=True if we see the prompt string
                # Stays set till the next newline char
                if oc == b"\n>>> "[prompt_char_count]:
                    at_prompt = False           # Reset at_prompt after '\n'
                    prompt_char_count += 1
                    if prompt_char_count == 5:
                        prompt_char_count = 0
                        at_prompt = True
                else:
                    prompt_char_count = 0
    readline.write_history_file(history_file)


from mpremote import main

# Override the mpremote main repl loop!!!
main.do_repl_main_loop = my_do_repl_main_loop

# The following could be extracted into command.py
import time, cmd, shutil, traceback, json, inspect
import shlex, glob, fnmatch, subprocess, itertools


class LocalCmd(cmd.Cmd):
    prompt = '\r>>> !'
    doc_header = """Execute a shell command on the local host, eg:
                    !ls
                    !cd ..
                 """

    # Completion of filenames on the local filesystem
    def completedefault(  # type: ignore
            self, match: str, line: str,
            begidx: int, endidx: int) -> List[str]:
        'Return a list of files on the local host which start with "match".'
        try:
            sep = match.rfind('/')
            d, match = match[:sep + 1], match[sep + 1:]
            _, dirs, files = next(os.walk(d or '.'))
            files = [d + f for f in files if f.startswith(match)]
            files.extend(d + f + '/' for f in dirs if f.startswith(match))
            files.sort()
            return files
        except Exception:
            traceback.print_exc()
            return []

    # Completion of directories on the local filesystem
    def complete_cd(
            self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        'Return a list of directories which start with "match".'
        return [
            f for f in self.completedefault(text, line, begidx, endidx)
            if f.endswith('/')]

    def do_cd(self, line: str) -> None:
        """Change the current directory on the local host:
            !cd ..
        This will call os.chdir() instead of executing in a sub-shell."""
        for arg in shlex.split(line):
            os.chdir(arg)
        print(os.getcwd())

    def default(self, line: str) -> bool:
        os.system(line)
        return True

    def emptyline(self) -> bool:
        return True

    def postcmd(self, stop: Any, line: str) -> bool:
        return True


class AnsiColour:
    'A class to colourise text with ANSI escape sequences'
    def __init__(self, enable: bool = True):
        self._enable = enable
        # Load the colour specification for the "ls" command
        spec = (
            os.getenv('LS_COLORS') or
            subprocess.check_output(
                'eval `dircolors`; echo -n $LS_COLORS',
                shell=True, text=True) or
            'di=01;34:*.py=01;36:').rstrip(':')  # A fallback color spec
        self.spec = {
            k.lstrip('*'): v for k, v in
            (c.split('=') for c in spec.split(':'))} if spec else {}
        if '.py' not in self.spec:     # A fallback colour for *.py files
            self.spec['.py'] = '01;36'
        # Dict of ansi colour specs by name
        self.colour = {  # ie: {'black': '00;30', ... 'white': '00;37'}
            name: '00;3{}'.format(i)
            for i, name in enumerate((
                'black', 'red', 'green', 'yellow',
                'blue', 'magenta', 'cyan', 'white'))}
        self.colour.update(dict(   # Add the bright/bold colour variants
            ('bold-' + x, '01' + spec[2:])
            for x, spec in self.colour.items()))
        self.colour['reset'] = '0'
        self.colour['bold'] = '01'

    def enable(self, enable: bool = True) -> None:
        """Enable or disable colourising of text with ansi escapes."""
        self._enable = enable

    def ansi(self, spec: str, bold: Optional[bool] = None) -> str:
        return '\x1b[{}m'.format(self.bold(self.colour.get(spec, spec), bold))

    def colourise(
            self, spec: str, word: str,
            bold: Optional[bool] = None, reset: str = '0') -> str:
        """Return "word" colourised according to "spec", which may be a colour
        name (eg: 'green') or an ansi sequence (eg: '00;32')."""
        if not spec or not self._enable:
            return word
        spec, reset = (
            self.colour.get(spec, spec),
            self.colour.get(reset, reset))
        spec = self.bold(spec, bold)
        return '\x1b[{}m{}\x1b[{}m'.format(spec, word, reset)

    def __call__(
            self, spec: str, word: str,
            bold: Optional[bool] = None, reset: str = '0') -> str:
        """Return "word" colourised according to "spec", which may be a colour
        name (eg: 'green') or an ansi sequence (eg: '00;32')."""
        return self.colourise(spec, word, bold, reset)

    def bold(self, spec: str, bold: Optional[bool] = True) -> str:
        """Set the "bold" attribute in an ansi colour "spec" if "bold" is
        True, or unset the attribute if "bold" is False."""
        spec = self.colour.get(spec, spec)
        return (
            spec if bold is None else
            (spec[:1] + ('1' if bold else '0') + spec[2:]))

    def pick(self, file: str, bold: Optional[bool] = None) -> str:
        """Pick a colour for "file" according to the "ls" command."""
        spec = (
            self.spec.get('di', '') if file[-1] == '/' else
            self.spec.get(os.path.splitext(file)[1], ''))
        return self.bold(spec, bold)

    # Return a colour decorated filename
    def file(self, file: str, reset: str = '0') -> str:
        """Return "file" colourised according to the colour "ls" command."""
        return self.colourise(self.pick(file), file, reset=reset)

    # Return a colour decorated directory
    def dir(self, file: str, reset: str = '0') -> str:
        """Return "dir" colourised according to the colour "ls" command."""
        return self.colourise(self.spec.get('di', ''), file, reset=reset)

    def colour_stack(self, text: str) -> str:
        """Change the way colour reset sequence ("\x1b[0m") works.
        Change any reset sequences to pop the colour stack rather than
        disabling colour altogether."""
        stack = ['0']

        def ansistack(m: Any) -> Any:
            # Return the replacement text for the reset sequence
            colour: str = m.group(2)
            if colour != '0':   # If this is not a colour reset sequence
                stack.append(colour)            # Save on the colour stack
            else:               # If this is a colour reset sequence
                if len(stack) > 0: stack.pop()  # Pop the stack first
                colour = stack[-1]      # Replace with top colour on stack
            return '\x1b[' + colour + 'm'

        return (re.sub('(\x1b\\[)([0-9;]+)(m)', ansistack, text) +
                (self.ansi('reset') if stack else ''))  # Force reset at end


# A collection of helper functions for file listings and filename completion
# to be uploaded to the micropython board and processed on the local host.
class MagicHelper:
    # The helper code which runs on the micropython board
    cmd_hook_code = """\
class _MagicHelper:
    import uos

    def ls_dir(self, dir, long, recursive):
        print('("{}",['.format(dir), end='')
        dirs = []
        for f, mode, *_ in uos.ilistdir(dir):
            if mode & 0x4000:   # File is a directory
                if recursive > 0 and f[0] != '.':
                    dirs.append(f)
                f += '/'
            if long:
                s = uos.stat(dir + ('/' if dir[-1] != '/' else '') + f)
                print('("{}",{},{}),'.format(
                    f, 0 if s[0] & 0x4000 else s[6], s[8]), end='')
            else:
                print('"{}",'.format(f), end='')
        print(']),')

        for f in dirs:
            self.ls_dir(
                dir + ('/' if dir[-1] != '/' else '') + f,
                long, recursive - 1)

    def ls(self, args, long=False, recursive=0):
        args = args or ['.']
        dirs = []
        print('[')
        for f in args:
            try:
                s = uos.stat(f)
            except OSError as err:
                e = [f, "OSError:"]; e.extend(err.args)
                print('{},'.format(e))
                continue
            if s[0] & 0x4000:  # File is a directory
                dirs.append(f.rstrip('/') or '/')
            else:
                if long:
                    print('("{}",{},{}),'.format(f, s[6], s[8]))
                else:
                    print('"{}",'.format(f))

        for f in dirs:
            self.ls_dir(f, long, recursive)
        print(']')

    def cp_file(self, f1, f2):
        f1, f2 = open(f1, "rb"), open(f2, "wb")
        buf = bytearray(1024)
        n = f1.readinto(buf)
        while n > 0:
            f2.write(buf, n)
            n = f1.readinto(buf)
        f1.close(); f2.close()

    def cp_dir(self, dir, dest, r=0):
        if r <= 0:
            print("Can not copy directory {}: Increase recursion".format(dir))
            return
        dest += '/' + dir[dir.rfind('/')+1:]
        try:
            uos.mkdir(dest)
        except:
            if not uos.stat(dest)[0] & 0x4000:
                print('Can not overwrite non-directory {} with directory {}'
                    .format(dest, dir))
                return
        print("mkdir:", dest)
        for f, m, *_ in uos.ilistdir(dir):
            if m & 0x4000 and r > 0:
                self.cp_dir(dir + '/' + f, dest, r - 1)
            else:
                self.cp_file(dir + '/' + f, dest + '/' + f)

    def cp(self, files, r=0):
        try:
            s = uos.stat(files[-1])
        except OSError:
            s = (0,)
        if len(files) == 2 and not s[0] & 0x4000:
            self.cp_file(files[0], files[1])
            return
        elif not s[0] & 0x4000:
            print("Destination must be a directory.")
            return
        for f in files[:-1]:
            if uos.stat(f)[0] & 0x4000:
                self.cp_dir(f, files[-1], r)
            else:
                self.cp_file(f, files[-1] + '/' + f[f.rfind('/')+1:])

    def mv(self, files):
        try:
            dir_dest = uos.stat(files[-1])[0] & 0x4000
        except OSError:
            dir_dest = False
        if len(files) == 2 and not dir_dest:
            uos.rename(files[0], files[1])
            return
        elif not dir_dest:
            print("Destination must be a directory.")
            return
        for f in files[:-1]:
            f2 = files[-1] + '/' + f[f.rfind('/')+1:]
            uos.rename(f, f2)

    def rm(self, files, r=0):
        for f in files:
            try:
                uos.remove(f)
                continue
            except OSError:
                pass
            try:
                m = uos.stat(f)[0]
            except OSError:
                print('No such file:', f)
                break
            if m & 0x4000:
                if r > 0:
                    self.rm(((f + '/' + i[0]) for i in uos.ilistdir(f)), r - 1)
                    uos.rmdir(f)
                else:
                    print("Can not remove directory {}: Increase recursion"
                        .format(f))
            else:
                print('Unable to remove:', f)

    def mkdir(self, dir):
        import uos
        try:
            s = uos.stat(dir)
        except OSError:
            uos.mkdir(dir)
            print(True)
        else:
            print((s[0] & 0x4000) != 0)

    def f_m(self, match):  # file_matches for filename completion
        sep = match.rfind('/')
        d, match = match[:sep+1] or '.', match[sep+1:]
        try:
            matches = [
                (d if d != '.' else '') + f[0] +
                ('/' if f[1] & 0x4000 else '')  # Add / to directories
                for f in uos.ilistdir(d) if f[0].startswith(match)]
        except OSError:
            matches = '[]'
        print(matches)

    import gc

    def pr(self):   # Return some dynamic values for the command prompt
        print(
            '("',uos.getcwd(),'",',gc.mem_alloc(),',',gc.mem_free(),')',
            sep='')

_helper = _MagicHelper()
"""

    # Apply basic compression on hook code - (from mpremote tool).
    HookSubsType = List[Tuple[str, str, Dict[str, int]]]
    hook_subs: HookSubsType = [
        (" *#.*$",  "",     {'flags': re.MULTILINE}),
        ("\n\n+",   "\n",   {}),
        ("    ",    " ",    {}),
        (r"([,;])  *",    r"\1",    {}),
        (r"  *([=+-])  *",   r"\1",    {}),
    ]

    @staticmethod
    def do_hook_subs(subs: HookSubsType, code: str) -> str:
        'Apply compression techniques to the code before uploading to board.'
        for sub in subs:
            a, b, flags  = sub
            code         = re.sub(a, b, code, **flags)
        return code

    def __init__(self) -> None:
        MagicHelper.cmd_hook_code = (
            MagicHelper.do_hook_subs(
                MagicHelper.hook_subs, MagicHelper.cmd_hook_code))

    # Type hints for the file listing data
    LsShortStyle = List[str]
    LsLongStyle  = List[Tuple[str, int, int]]
    LsFileList   = Union[LsShortStyle, LsLongStyle]

    # Methods to process data returned from the helper functions
    def ls_files(self, file_list: LsFileList, colour: AnsiColour) -> None:
        '''Print a file listing (long or short style) from data returned
        from the board.'''
        # Pretty printing for files on the board
        if not file_list:
            return
        columns = shutil.get_terminal_size().columns
        file_list.sort()
        if isinstance(file_list[0], str):
            files = cast(MagicHelper.LsShortStyle, file_list)
            # Short listing style - data is a list of filenames
            if len(files) < 20 and sum(len(f) + 2 for f in files) < columns:
                # Print all on one line
                for f in files:
                    print(colour.file(f), end='  ')
                print('')
            else:
                # Print in columns - by row
                w = max(len(f) for f in files) + 2
                spaces = ' ' * w
                cols = columns // w
                n = 1
                for f in files:
                    print(
                        colour.file(f), spaces[len(f):], sep='',
                        end=('' if n % cols and n < len(files) else '\n'))
                    n += 1
        else:
            # Long listing style - data is tuples of (filename, size, mtime)
            files_long = cast(MagicHelper.LsLongStyle, file_list)
            for f, size, mtime in files_long:
                if mtime < 40 * 31536000:  # ie. before 2010
                    mtime += 946684800   # Correct for epoch=2000 on uPython
                print('{:9d} {} {}'.format(
                    size,
                    time.strftime('%a %x %X', time.localtime(mtime))[:-3],
                    colour.file(f)))

    # File listing: response is received from _helper.ls() on the board
    def ls(self, response: bytes, colour: AnsiColour) -> None:
        'Print a nice file listing from the data sent back from the board.'
        if not response:
            return
        file_list = eval(response)
        # First print any error messages from missing files: present as lists
        for err in (f for f in file_list if isinstance(f, list)):
            print('ls: connot access \'{}\': Not found: {}'.format(
                err[0], err[1:]))

        # Print any files listed on the command line
        files = [
            f for f in file_list
            if isinstance(f, str) or (isinstance(f, tuple) and len(f) == 3)]
        self.ls_files(cast(MagicHelper.LsFileList, files), colour)

        # Print the listings of args which are directories
        # Each dir is a tuple with len == 2: (dirname, [file1, file2, ..])
        dirs = [
            f for f in file_list
            if isinstance(f, tuple) and len(f) == 2]
        dirs.sort()
        first_time = not files
        for dir, files in dirs:
            if not first_time:
                print('')           # Insert a blank line between listings
            first_time = False
            if len(dirs) > 1:
                print('{}:'.format(dir.rstrip('/') or '/'))
            if files:
                self.ls_files(cast(MagicHelper.LsFileList, files), colour)


class RemoteCmd(cmd.Cmd):
    base_prompt: str = '\r>>> '
    doc_header: str = (
        'Execute "%magic" commands at the micropython prompt, eg: %ls /\n'
        'Use "%%" to enter multiple command mode.\n'
        'Furhter help is available for the following commands:\n'
        '======================================================')
    ruler = ''
    remote_cmds = (  # Commands for which glob expansion happens on the board
        'ls', 'cat', 'edit', 'touch', 'mv', 'cp', 'rm', 'get',
        'cd', 'mkdir', 'rmdir', 'echo')

    def __init__(self, pyb: PyboardExtended, console_out_write: Writer):
        self.pyb                = pyb
        self.colour             = AnsiColour()
        self._helper            = MagicHelper()
        self.write_fn           = console_out_write
        self.prompt             = self.base_prompt
        self.prompt_fmt         = ('{bold-cyan}{id} {yellow}{platform}'
                                   ' ({free}){bold-blue}{pwd}> ')
        self.hooks_loaded       = False
        self.options_loaded     = False
        self.rcfile_loaded      = False
        self.single_cmd_mode    = True
        self.prompt_colour      = 'yellow'
        self.alias              = {'ll': 'ls -l'}
        self.board              = {'device': self.pyb.device_name}
        self.names: Dict[str, str] = {}
        self.colour_spec_extra: Dict[str, str] = {}
        # The shortname/alias for the device, eg: '/dev/ttyUSB0' -> 'u0'
        match = re.match(r'^/dev/tty(.).*(.)$', self.board['device'].lower())
        self.board['dev'] = ''.join(match.groups()) if match else '??'
        self.board.update({c: self.colour.ansi(c) for c in self.colour.colour})
        readline.set_completer_delims(' \t\n>;')
        super().__init__()

        # Set the completion functions
        fname = self.complete_filename
        self.complete_ls        = fname
        self.complete_cat       = fname
        self.complete_edit      = fname
        self.complete_touch     = fname
        self.complete_mv        = fname
        self.complete_cp        = fname
        self.complete_rm        = fname
        self.complete_get       = fname
        fname = self.complete_directory
        self.complete_cd        = fname
        self.complete_mkdir     = fname
        self.complete_rmdir     = fname
        fname = self.complete_local_filename
        self.complete_put       = fname
        self.complete_run       = fname
        self.complete_shell     = fname
        fname = self.complete_local_directory
        self.complete_mount     = fname
        self.complete_lcd       = fname

    def load_rc_file(self, file: str) -> bool:
        'Read commands from "file" first in home folder then local folder.'
        for rcfile in [os.path.expanduser('~/' + file), file]:
            lines = []
            try:
                # Load and close file before processing as cmds may force
                # re-write of file (eg. ~/.mpr-thing.options)
                with open(rcfile, 'r') as f:
                    lines = list(f)
            except OSError:
                pass
            for line in lines:
                self.onecmd(line)
            return True
        return False

    def write(self, response: bytes) -> None:
        'Call the console writer for output (convert "str" to "bytes").'
        if response:
            if not isinstance(response, bytes):
                response = bytes(response, 'utf-8')
            self.write_fn(response)

    ## Execute stuff on the micropython board
    def exec(self, code: str, data_consumer: Optional[Writer] = None) -> bytes:
        'Execute some code on the micropython board.'
        response: bytes = b''
        with catcher(self.write):
            response = self.pyb.exec_(code, data_consumer)
        return response

    def eval_exec(self, code: str) -> Any:
        return eval(self.exec(code))

    def write_exec(self, code: str) -> None:
        self.exec(code, stdout_write_bytes)

    ## File commands
    def do_ls(self, args: List[str]) -> None:
        """
        List files on the board:
            %ls [-[lR]] [file_or_dir1 ...]
        The file listing will be colourised the same as "ls --color". Use the
        "set" command to add or change the file listing colours."""
        opts = ''
        if args and args[0][0] == "-":
            opts, *args = args
        self._helper.ls(self.exec(
            '_helper.ls({}, {}, {})'.format(
                args,                        # Dirs and files to list
                "l" in opts,                 # Use a long-style listing
                10 if "R" in opts else 0)),  # Max recursion = 10
            self.colour)

    def do_cat(self, args: List[str]) -> None:
        """
        List the contents of files on the board:
            %cat file [file2 ...]"""
        for arg in args:
            with catcher(self.write):
                self.pyb.fs_cat(arg)
            self.write(b'\r\n')

    def do_edit(self, args: List[str]) -> None:
        """
        Copy a file from the board, open it in your editor, then copy it back:
            %edit file1 [file2 ...]
        """
        for arg in args:
            import tempfile
            fd, fname = tempfile.mkstemp()
            os.close(fd)
            with catcher(self.write):
                self.pyb.fs_get(arg, fname)
                if 0 == os.system(f'eval ${{EDITOR:-/usr/bin/vi}} {fname}'):
                    self.pyb.fs_put(fname, arg)
            os.remove(fname)

    def do_touch(self, args: List[str]) -> None:
        """
        Create a file on the board:
            %touch file [file2 ...]"""
        for arg in args:
            self.write_exec('open("{}", "a").close()'.format(arg))

    def do_mv(self, args: List[str]) -> None:
        """
        Rename/move a file or directory on the board:
            %mv old new
            %mv *.py /app"""
        self.write_exec('_helper.mv({})'.format(
            [f.rstrip('/') if f != '/' else f for f in args]))

    def do_cp(self, args: List[str]) -> None:
        """
        Make a copy of a file or directory on the board, eg:
            %cp [-r] existing new
            %cp *.py /app"""
        opts = ''
        if args and args[0][0] == "-":
            opts, *args = args
        self.write_exec(
            '_helper.cp({}, {})'.format(args, 10 if 'r' in opts else 0))

    def do_rm(self, args: List[str]) -> None:
        """
        Delete files from the board:
            %rm [-r] file1 [file2 ...]"""
        opts = ''
        if args and args[0][0] == "-":
            opts, *args = args
        self.write_exec(
            '_helper.rm({}, {})'.format(args, 10 if 'r' in opts else 0))

    def do_get(self, args: List[str]) -> None:
        """
        Copy a file from the board to a local folder:\n
            %get file1 [file2 ...]"""
        for arg in args:
            pwd: str = self.board['pwd']
            if (arg.startswith('/remote') or
                    (pwd.startswith('/remote') and not arg.startswith('/'))):
                print("%get: skipping remote mounted folder:", arg)
                continue
            filelist = self.eval_exec(
                '_helper.ls(["{}"], {}, {})'.format(arg, False, 10))
            for f in filelist:
                if isinstance(f, str):
                    # f is a file
                    with catcher(self.write):
                        print(os.path.basename(f), '<-', f)
                        self.pyb.fs_get(f, os.path.basename(f))
                elif isinstance(f, tuple) and len(f) == 2:
                    # f is a directory
                    base = os.path.dirname(arg.rstrip('/'))
                    base += '/' if base else ''
                    dir: str = f[0]; files: List[str] = f[1]
                    dest = dir[len(base):] if dir.startswith(base) else dir
                    dest = dest.lstrip('./')  # Strip leading slashes and ..
                    try:
                        if dest and not os.path.isdir(dest):
                            os.mkdir(dest)
                            print(dest)
                    except OSError:
                        print('%get: not a directory:', dest)
                        continue
                    for source in (f for f in files if f[-1] != '/'):
                        # Copy the regular files - ignore directories
                        f1 = os.path.join(dir, source)
                        f2 = os.path.join(dest, source)
                        with catcher(self.write):
                            print(f2)
                            self.pyb.fs_get(f1, f2)

    def do_put(self, args: List[str]) -> None:
        """
        Copy local files to the current folder on the board:
            %put file [file2 ...] [:dest]
        If the last argument start with ":" use that as the destination folder.
        """
        opts = ''
        if args and args[0][0] == "-":
            opts, *args = args
        pwd: str = self.board['pwd']
        if pwd.startswith('/remote'):
            print("%put: do not use on mounted folder:", pwd)
            return
        dest_dir = ''
        if args and args[-1].startswith(':'):
            dest_dir = args[-1][1:].rstrip('/') + '/'
            args = args[:-1]
        for arg in args:
            if not os.path.isdir(arg):
                with catcher(self.write):
                    f1, f2 = arg, dest_dir + os.path.basename(arg)
                    print(f2)
                    if 'n' not in opts:
                        self.pyb.fs_put(f1, f2)
            else:
                parent = os.path.dirname(arg)
                for path, _, files in os.walk(arg):
                    dir = dest_dir + os.path.relpath(path, parent)
                    print(dir)
                    if ('n' not in opts and not
                            self.eval_exec('_helper.mkdir("{}")'.format(dir))):
                        print('%put: not a directory:', dir)
                        continue
                    for f in files:
                        f1, f2 = path + '/' + f, dir + '/' + f
                        with catcher(self.write):
                            print(f2)
                            if 'n' not in opts:
                                self.pyb.fs_put(f1, f2)

    ## Directory commands
    def do_cd(self, args: List[str]) -> None:
        """
        Change the current direcory on the board (with os.setpwd()):
            %cd /lib"""
        arg = args[0] if args else '/'
        self.write_exec(
            'import uos;_f="{}";uos.stat(_f);uos.chdir(_f)'
            .format(arg))

    def do_pwd(self, args: List[str]) -> None:
        """
        Print the current working directory on the board:
            %pwd"""
        if args:
            print('pwd: unexpected args:', args)
        self.write_exec('import uos;print(uos.getcwd())')

    def do_lcd(self, args: List[str]) -> None:
        """
        Change the current directory on the local host:
            %lcd ..
        This is the same as:
            !cd .."""
        for arg in args:
            with catcher(self.write):
                os.chdir(arg)
                print(os.getcwd())

    def do_mkdir(self, args: List[str]) -> None:
        """
        Create a new directory on the board:
            %mkdir /test"""
        for arg in args:
            with catcher(self.write):
                self.pyb.fs_mkdir(arg)

    def do_rmdir(self, args: List[str]) -> None:
        """
        Delete/remove a directory on the board (if it is empty)
            %rmdir /test"""
        for arg in args:
            with catcher(self.write):
                self.pyb.fs_rmdir(arg)

    ## Execute code on the board
    def do_exec(self, args: List[str]) -> None:
        """
        Exec the python code on the board, eg.:
            %exec print(34 * 35)
        "\\n" will be substituted with the end-of-line character, eg:
            %exec 'print("one")\\nprint("two")' """
        self.write_exec(' '.join(args).replace('\\n', '\n'))

    def do_eval(self, args: List[str]) -> None:
        """
        Eval and print the python code on the board, eg.:
            %eval 34 * 35"""
        self.write_exec('print({})'.format(' '.join(args)))

    def do_run(self, args: List[str]) -> None:
        """
        Load and run local python files onto the board:
            %run file1.py [file2.py ...]"""
        for arg in args:
            try:
                with open(arg) as f:
                    buf = f.read()
            except OSError as err:
                print(OSError, err)
            else:
                self.write_exec(buf)

    def do_echo(self, args: List[str]) -> None:
        """
        Echo a command line after file pattern expansion:
           %echo *.py Make*"""
        print(' '.join(args))

    ## Board commands
    def do_uname(self, args: List[str]) -> None:
        """
        Print information about the hardware and software:
            %uname"""
        if args:
            print('uname: unexpected args:', args)
        self.write((
            'Micropython {nodename} ({unique_id}) '
            '{version} {sysname} {machine}'
            .format_map(self.board)).encode('utf-8') + b'\r\n')

    def do_time(self, args: List[str]) -> None:
        """
        Set or print the time on the board:
            %time set       : Set the RTC clock on the board from local time
            %time set utc   : Set the RTC clock on the board from UTC time
            %time           : Print the RTC clock time on the board"""
        if args and args[0] == 'set':
            from time import gmtime, localtime
            t = gmtime() if 'utc' in args else localtime()
            rtc_cmds = {
                'esp8266': 'from machine import RTC;RTC().datetime({})',
                'pyb':     'from pyb import RTC;RTC().datetime({})',
                'pycom':   'from machine import RTC;_t={};'
                           'RTC().init((_t[i] for i in [0,1,2,4,5,6]))',
            }
            fmt = rtc_cmds.get(
                self.board['sysname'],
                'from machine import RTC;RTC().init({})')
            self.write_exec(fmt.format(
                (t.tm_year, t.tm_mon, t.tm_mday, 0,
                    t.tm_hour, t.tm_min, t.tm_sec, 0)))
        from time import asctime
        t = self.eval_exec('import utime;print(utime.localtime())')
        self.write(asctime(
            (t[0], t[1], t[2], t[3], t[4], t[5], 0, 0, 0)).encode('utf-8')
            + b'\r\n')

    def do_mount(self, args: List[str]) -> None:
        """
        Mount a local folder onto the board at "/remote" as a Virtual
        FileSystem:
            %mount [folder]   # If no folder specified use '.'"""
        # Don't use relative paths - these can change if we "!cd .."
        path = os.path.realpath(args[0] if args else '.')
        if not os.path.isdir(path):
            print("%mount: No such directory:", path)
            return
        self.pyb.mount_local(path)
        self.write(
            'Mounted local folder {} on /remote\r\n'
            .format(path).encode('utf-8'))
        self.write_exec('import uos;print(uos.getcwd())')

    def do_umount(self, args: List[str]) -> None:
        """
        Unmount any Virtual Filesystem mounted at \"/remote\" on the board:
            %umount"""
        if args:
            print('umount: unexpected args:', args)
        # Must chdir before umount or bad things happen.
        self.write_exec(
            'import uos;uos.getcwd()[:7]=="/remote" and uos.chdir("/")')
        self.pyb.umount_local()
        self.write_exec('print(uos.getcwd())')

    def do_free(self, args: List[str]) -> None:
        """
        Print the free and used memory:
            %free"""
        verbose = '1' if args and args[0] == '-v' else ''
        self.write_exec(
            'from micropython import mem_info; mem_info({})'.format(verbose))

    def do_df(self, args: List[str]) -> None:
        """
        Print the free and used flash storage:
            %df"""
        if args:
            print('df: unexpected args:', args)
        with catcher(self.write):
            _, bsz, tot, free, *_ = self.eval_exec(
                'from uos import statvfs; print(statvfs("/"))')
            print("{:10} {:>9} {:>9} {:>9} {:>3}% {}".format(
                "", "Bytes", "Used", "Free", "Use", "Mounted on"))
            print("{:10} {:9d} {:9d} {:9d} {:3d}% {}".format(
                "/", tot * bsz, (tot - free) * bsz, free * bsz,
                round(100 * (1 - free / tot)), "/"))

    def do_gc(self, args: List[str]) -> None:
        """
        Run the micropython garbage collector on the board to free memory.
        Will also print the free memory before and after gc:
            %gc"""
        if args:
            print('gc: unexpected args:', args)
        with catcher(self.write):
            before, after = self.eval_exec(
                'from gc import mem_free,collect;'
                'b=mem_free();collect();print([b,mem_free()])')
            print("Before GC: Free bytes =", before)
            print("After  GC: Free bytes =", after)

    ## Extra commands
    def do_shell(self, args: List[str]) -> None:
        """
        Execute shell commands from the "%" prompt as well, eg:
            %!date"""
        if args and len(args) == 2 and args[0] == 'cd':
            os.chdir(args[1])
        else:
            os.system(' '.join(args))

    def do_alias(self, args: List[str]) -> None:
        """
        Assign an alias for other commands: eg:
            %alias ll="ls -l" lr="ls -lR"
            %alias connect='exec "network.WLAN(0).connect(\"{}\", \"{}\")"'
        You can use "{}" or "{2}" format specifiers to consume arguments when
        you use the alias: eg:
            %connect ssid password
        Any arguments which are not consumed by format specfiers will be
        added to the command after expanding the alias, eg:
            %ll /lib
        NOTE: "ll" and "lr" are pre-builtin as aliases as above.
        You can not override existing commands with an alias.
        """
        for arg in args:
            print(arg)
            alias, value = arg.split('=', maxsplit=1)
            if not alias or not value:
                print('Invalid alias: "{}"'.format(arg))
                continue
            self.alias[alias] = value.strip()

    def do_set(self, args: List[str]) -> None:
        """
        Set some options, eg:
            %set prompt='{cyan}{name}@{dev}-{sysname}-({free}){blue}{pwd}> '
            %set promptcolour=yellow
        Set and save the name of the current board (for use in prompt):
            %set name=node05
        Update the mapping of all device unique_ids and names (as json string):
            %set names='{"ab:cd:ef:01:23:45": "node01", ...}'
        Add extra colour specs (as json) for file listing with "ls":
            %set lscolour='{"di": "bold-blue", "*.py": "bold-cyan"}'
        """
        for arg in args:
            try:
                key, value = arg.split('=', maxsplit=1)
            except ValueError:
                key, value = '', ''
            if not key or not value:
                print("%set: invalid option setting:", arg)
                continue
            if key == 'prompt':
                saved = self.prompt_fmt
                with catcher(self.write):
                    self.prompt_fmt = value
                    backup = self.prompt
                    self.set_prompt()   # Check for errors in the prompt
                    self.prompt = backup
                if catcher.exception:   # Restore the old prompt_fmt
                    self.prompt_fmt = saved
            elif key == 'promptcolour':
                ansi = self.colour.ansi(value)
                if ansi[0] == '\x1b':
                    self.prompt_colour = value
                else:
                    print("%set: invalid colour:", self.prompt_colour)
            elif key == 'names':
                try:
                    self.names.update(json.loads(value))
                except ValueError as err:
                    print('%set:', err)
            elif key == 'name':
                self.names[self.board['unique_id']] = value
            elif key == 'lscolour':
                d: Dict[str, str] = {}
                d.update(json.loads(value))
                for k, v in d.items():
                    colour = self.colour.ansi(v)
                    if colour[0] != '\x1b':
                        print('%set: unknown colour:', v)
                        continue
                    self.colour_spec_extra[k.lstrip('*')] = v
                self.colour.spec.update(self.colour_spec_extra)
            else:
                print("%set: unknown key:", key)
        # Save the options in a startup file
        if not self.options_loaded:  # - unless we are reading the options file
            return
        with open(OPTIONS_FILE if os.path.isfile(OPTIONS_FILE) else
                  os.path.expanduser('~/' + OPTIONS_FILE), 'w') as f:
            f.write(
                '# Edit with caution: will be overwritten by mpr-thing.\n')
            f.write('set prompt="{}"\n'.format(self.prompt_fmt))
            f.write('set promptcolour="{}"\n'.format(self.prompt_colour))
            f.write('set names=\'{}\'\n'.format(json.dumps(self.names)))
            f.write('set lscolour=\'{}\'\n'.format(
                json.dumps(self.colour_spec_extra)))

    def help_set(self) -> None:
        if self.do_set.__doc__:
            print(inspect.cleandoc(self.do_set.__doc__))
        print((
            '\nThese options will be automatically saved in ~/{0}\n'
            'or ./{0} (if it exists).\n'
            '\nPrompts are python format strings and may include:\n    ')
            .format(OPTIONS_FILE),
            end='')
        for i, k in enumerate(self.board.keys()):
            print(
                "{:15}".format('{' + k + '}'),
                end='' if (i + 1) % 5 else '\n    ')
        print('\n')
        print(inspect.cleandoc("""
        Where:
            {device/dev}: full or short name for the serial device
            {colour/bold-colour}: insert an ANSI colour sequence
            {reset}: pop the colour stack
            {free/_pc}: the current free heap memory in bytes/percentage
            {sysname/nodename/release/version/machine}: set from uos.uname()
            {unique_id/id} from machine.unique_id() (id is last 3 octets)
            {pwd}: current working directory on board
            {lcdn}: last n parts of local working directory
            {name}: name of current board or {id} if name is not set"""))

    def do_help(self, args: List[str]) -> None:  # type: ignore
        'List available commands with "help" or detailed help with "help cmd".'
        # Need to override Cmd.do_help since we abuse the args parameter
        if not args:
            super().do_help('')
            return
        arg = args[0]
        try:
            func = getattr(self, 'help_' + arg)
        except AttributeError:
            try:
                doc = getattr(self, 'do_' + arg).__doc__
                if doc:
                    self.stdout.write(inspect.cleandoc(doc))
                    self.stdout.write('\n')
                    return
            except AttributeError:
                pass
            self.stdout.write("%s\n" % str(self.nohelp % (arg,)))
            return
        func()

    ## File and directory completion functions
    def complete_filename(
            self, word: str, line: str, begidx: int, endidx: int) -> List[str]:
        'Return a list of filenames on the board starting with "word".'
        words: List[str] = []
        with catcher(self.write):
            words = self.eval_exec(
                '_helper.f_m("{}")'.format(word))
            return words
        return []

    def complete_directory(
            self, word: str, line: str, begidx: int, endidx: int) -> List[str]:
        'Return a list of directories on the board starting with "match".'
        return [
            f for f in self.complete_filename(word, line, begidx, endidx)
            if f.endswith('/')]

    def complete_local_filename(
            self, word: str, line: str, begidx: int, endidx: int) -> List[str]:
        'Return a list of local filenames starting with "match".'
        with catcher(self.write):
            sep = word.rfind('/')
            d, match = word[:sep + 1], word[sep + 1:]
            _, dirs, files = next(os.walk(d or '.'))
            files = [d + f for f in files if f.startswith(match)]
            files.extend(d + f + '/' for f in dirs if f.startswith(match))
            files.sort()
            return files
        return []

    def complete_local_directory(
            self, word: str, line: str, begidx: int, endidx: int) -> List[str]:
        'Return a list of local directories starting with "match".'
        return [
            f for f in self.complete_local_filename(word, line, begidx, endidx)
            if f.endswith('/')]

    def reload_hooks(self) -> None:
        'Load/reload the helper code onto the micropython board.'
        self.write_exec(self._helper.cmd_hook_code)
        self.hooks_loaded = True
        self.write_exec('_helper.localtime_offset = {}'.format(-time.timezone))
        self.board.update(      # Update the board params from uos.uname()
            self.eval_exec('import uos;print("dict{}".format(uos.uname()))'))
        self.board['platform'], self.board['unique_id'] = (
            self.eval_exec(
                'from machine import unique_id;from sys import platform\n'
                'print("({}, {})".format(repr(platform), unique_id()))'))
        self.board['unique_id'] = self.board['unique_id'].hex(':')
        self.board['id'] = self.board['unique_id'][-8:]  # Last 3 octets

    def reset_hooks(self) -> None:
        self.hooks_loaded = False

    ## Command line parsing, splitting and globbing
    def glob_remote(self, path: str) -> Generator[str, None, None]:
        'Expand glob patterns in the filename part of "path".'
        sep = path.rfind('/')
        dir, pattern = path[:sep + 1], path[sep + 1:]
        if '*' not in pattern and '?' not in pattern:
            return (f for f in [])  # type: ignore
        files = []
        with catcher(self.write):
            files = self.eval_exec('_helper.f_m("{}")'.format(dir))
        return (                    # Just return the generator
            f for f in files
            if f[0] != '.' and fnmatch.fnmatch(f, pattern))

    def glob(self, cmd: str, args: List[str]) -> Generator[str, None, None]:
        remote_glob = cmd in self.remote_cmds
        for arg in args:
            if arg:
                at_least_one = False
                for f in (self.glob_remote(arg) if remote_glob else
                          glob.iglob(arg)):
                    at_least_one = True
                    yield f
                if not at_least_one:
                    yield arg   # if no match - just return the glob pattern

    def split(self, line: str) -> List[str]:
        'Split the command line into tokens and expand any glob patterns.'
        # punctuation_chars=True ensures semicolons can split commands
        lex = shlex.shlex(line, None, True, True)
        lex.wordchars += ':'
        allargs = list(lex)

        # Semicolons separate commands: make a list of args for each sub-cmd
        # [[arg1, ...], [arg1,...], ...]
        argslist = (
            list(l) for key, l in
            itertools.groupby(allargs, lambda arg: arg == ';') if not key)
        # If first arg was ';' use empty args, else use the first in argslist
        args = next(argslist) if allargs and allargs[0] != ';' else []
        # Push the rest of the args back onto the cmd queue
        self.cmdqueue.extend(list(argslist))  # type: ignore
        return args

    ## Cmd control functions
    def preloop(self) -> None:
        if not self.hooks_loaded:
            self.reload_hooks()     # Load the helper code onto the board
        if not self.options_loaded:
            self.load_rc_file(OPTIONS_FILE)
            self.options_loaded = True
        if not self.rcfile_loaded:
            self.load_rc_file(RC_FILE)
            self.rcfile_loaded = True
        self.single_cmd_mode = True
        self.prompt = \
            self.colour(self.prompt_colour, self.base_prompt) + '%'

    def postloop(self) -> None:
        print(self.base_prompt, end='')

    def precmd(self, line: str) -> str:
        if isinstance(line, list):
            return line
        if not self.single_cmd_mode and line and line[0] == "%":
            line = line[1:]     # Discard any leading '%' in multi-cmd mode
            readline.replace_history_item(1, line)

        return line

    def postcmd(self, stop: Any, line: str) -> bool:
        if not self.single_cmd_mode:
            self.set_prompt()       # Setup our complicated prompt
        # Exit if we are in single command mode and no commands in the queue
        return self.single_cmd_mode and not self.cmdqueue

    def onecmd(self, line: str) -> bool:
        """Override the default Cmd.onecmd()."""
        if isinstance(line, list):
            # List of str is pushed back onto cmdqueue in self.split()
            cmd, *args = line
        else:
            # A command line read from the input
            cmd, arg, line = self.parseline(line)
            try:
                args = list(self.split(arg)) if arg else []
            except ValueError as err:
                print('%magic command error:', err)
                return False
        if not line:
            return self.emptyline()
        if not cmd:
            return self.default(line)
        self.lastcmd = ''
        with catcher(self.write):
            func = getattr(self, 'do_' + cmd, None)
            if func:
                func(list(self.glob(cmd, args)))
            else:
                return self.default(line)
        return False

    def emptyline(self) -> bool:
        return True    # Else empty lines repeat last command

    def default(self, line: str) -> bool:
        if self.single_cmd_mode and line.strip() == "%":
            # User typed '%%': Enter command line mode
            self.prompt = "%% "
            self.write(
                b'Enter magic commands (try "help" for a list)\n'
                b'Type "quit" or ctrl-D to return to micropython:\n')
            self.single_cmd_mode = False
            return True
        elif (not self.single_cmd_mode and
                line.strip() in ('exit', 'quit', 'EOF')):
            # End command line mode - typed "quit", "exit" or ctrl-D
            self.prompt = self.base_prompt
            self.single_cmd_mode = True
            if line.strip() == 'EOF':
                print()
            return True

        # Check for any aliases...
        args = list(self.split(line))
        if args and args[0] in self.alias:
            cmd, *args = args
            alias = self.alias[cmd]

            # Expand the alias: can include format specifiers: {}, {3}, ...
            line = alias.format(*args)
            # Set of arg indices consumed by fmt specifiers: {}, {:23}, ...
            used = set(range(len(re.findall(r'{(:[^}]+)?}', alias))))
            # Add args consumed by {3}, {6:>23}, ...
            used.update(
                int(n) for n in re.findall(r'{([0-9]+):?[^}]*}', alias))
            # Add any unused args to the end of the line
            line = ' '.join((
                line,
                ' '.join(arg for n, arg in enumerate(args) if n not in used)))

            print(line)
            self.onecmd(line)
            return True
        elif not args:
            return True         # Ignore comments

        self.write('Unknown command: "{}"\r\n'.format(line.strip()).encode())
        return True

    def set_prompt(self) -> None:
        "Set the prompt using the prompt_fmt string."
        pwd: str; alloc: int; free: int
        pwd, alloc, free = self.eval_exec('_helper.pr()')
        alloc, free = int(alloc), int(free)
        free_pc = round(100 * free / (alloc + free))

        # Update some dynamic info for the prompt
        self.board['pwd']       = pwd
        self.board['free']      = free
        self.board['free_pc']   = free_pc
        self.board['lcd']       = os.getcwd()
        self.board['lcd3']      = '/'.join(os.getcwd().rsplit('/', 3)[1:])
        self.board['lcd2']      = '/'.join(os.getcwd().rsplit('/', 3)[1:])
        self.board['lcd1']      = '/'.join(os.getcwd().rsplit('/', 3)[1:])
        self.board['name'] = self.names.get(    # Look up name for board
            self.board['unique_id'], self.board['id'])

        prompt_colours = {
            'free':     ('green' if free_pc > 50 else
                         'yellow' if free_pc > 25 else
                         'red'),
            'free_pc':  ('green' if free_pc > 50 else
                         'yellow' if free_pc > 25 else
                         'red'),
        }
        prompt_map = {
            k: self.colour(prompt_colours.get(k, ''), v)
            for k, v in self.board.items()}

        self.prompt = (
            # Make GNU readline calculate the length of the colour prompt
            # correctly. See readline.rl_expand_prompt() docs.
            re.sub(
                '(\x1b\\[[0-9;]+m)', '\x01\\1\x02',
                # Make colour reset act like a colour stack
                self.colour.colour_stack(
                    # Build the prompt from prompt_fmt (set with %set cmd)
                    self.prompt_fmt.format_map(prompt_map))))


if __name__ == "__main__":
    sys.exit(main.main())
